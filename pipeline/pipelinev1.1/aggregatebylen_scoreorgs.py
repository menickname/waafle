#!/usr/bin/python

'''
This code will:
1) Generate scores for each organism in each group within a contig.
2) Scores are generated by %coverage_over_group*%ID. They are not reliant on the "best" hit, but the combination of all hits that align to that particular taxon level. This was previously ccalled the 'Vote Method'.
3) Contigs that consist of only 1 group will be removed.

Output is in:
1) Dictionary that consists of {contig: {group: {org: score}}} in a json file.
2) Dictionary that consists of {contig: {org: {group: score}}} in a json file.
'''

#Import
import argparse
import re
import json

#Define arguments
parser = argparse.ArgumentParser()
parser.add_argument('blast_output', help = 'Location and file of processed BLAST output')
parser.add_argument('organism', help = "Determine what taxonomy level to do this at; it should be one of the letters: 'k', 'p', 'c', 'o', 'f', 'g', 's'")
#parser.add_argument('delta', type = float, help = 'Determine the higher threshold score. Those above this score are high confidence BLAST hits')
#parser.add_argument('epsilon', type = float, help = 'Determine the lower threshold score. Those below this score are low confidence BLAST hits')
args = parser.parse_args()


#Define function for calculating overlap
def calcOverlap(iStart1, iEnd1, iStart2, iEnd2):
        listcoord = [float(iStart1), float(iEnd1), float(iStart2), float(iEnd2)]
        listcoord.sort()
        contig1len = iEnd1 - iStart1 + 1
        contig2len = iEnd2 - iStart2 + 1
        divisor = min(contig1len, contig2len)
        overlap = (listcoord[2]-listcoord[1] + 1)/divisor
        return overlap


#Create a dictionary with contigs as keys and alignments as items
dictContigHits = {}
for astrline in open(args.blast_output):
	aItems = astrline.strip().split('\t')
	dictContigHits.setdefault(aItems[0], []).append(aItems)


#Create a dictionary of dictionaries, with contigs as the keys for the first dictionary, groups as the keys of the nested dictionary, and alignments as the items of the nested dictionary.
ddictContigGroupHits = {}
for bstrline in dictContigHits.iterkeys():
	dictGroupHits = {}
	for i in range(len(dictContigHits[bstrline])):
		group = dictContigHits[bstrline][i][14]
		dictGroupHits.setdefault(group, []).append(dictContigHits[bstrline][i])
	ddictContigGroupHits.setdefault(bstrline, {}).update(dictGroupHits)


#Create a dictionary of dictionaries, with contigs as the keys for the first dictionary, groups as keys of the nested dictionary, and group lengths as the items of the nested dictionary
ddictContigGroupLen = {}
for cstrline in ddictContigGroupHits.iterkeys():
	for dstrline in ddictContigGroupHits[cstrline].iterkeys():
		groupStart = []
		groupEnd = []
		for i in range(len(ddictContigGroupHits[cstrline][dstrline])):
			alignment = ddictContigGroupHits[cstrline][dstrline][i]
			groupStart.append(float(alignment[6]))
			groupEnd.append(float(alignment[7]))
		groupLength = max(groupEnd) + 1 - min(groupStart)
		group_length = {dstrline: groupLength}
		ddictContigGroupLen.setdefault(cstrline, {}).update(group_length)
filename1 = 'ddictContigGroupLen.json'
with open(filename1, "w") as outfile1:
        json.dump(ddictContigGroupLen, outfile1)

with open('dictContigLength.json') as infile3:
        dictContigLength = json.load(infile3)

#Loop through all contigs
dddictOrgGroupScore = {}
dddictGroupOrgScore = {}
file = open('hgtnegative_1group.txt', 'w')

for contig in ddictContigGroupHits.iterkeys():
	ddictGroupOrgHits = {}
	if len(ddictContigGroupHits[contig]) == 1: #Skip contig if it only has 1 group to begin with
		onecontigList = []
		group1 = ddictContigGroupHits[contig].keys()[0] 
		for alignment in range(len(ddictContigGroupHits[contig][group1])):
			myalign = ddictContigGroupHits[contig][group1][alignment]
			taxonomyinfo = myalign[1].strip().split('|')
			taxonomy = taxonomyinfo[len(taxonomyinfo)-1]
			searchstring = args.organism + '__\w*'
                        organism = re.search(searchstring, taxonomy).group()
			percID, alignLen = float(myalign[2]), float(myalign[7]) - float(myalign[6]) + 1
			score = percID*(alignLen/float(ddictContigGroupLen[contig][group1]))
			coverage = alignLen/float(dictContigLength[contig])
			onecontiginfo = score, contig, alignLen, organism, coverage
			onecontigList.append(onecontiginfo)
		onecontigList.sort()
		file.write(onecontigList[0][1] + '\t' + str(dictContigLength[contig]) + '\t' + onecontigList[0][3] + '\t' + str(score) + '\t' + str(coverage) + '\t' + '1grouponly' + '\t' + 'nohgt' + '\n')
	else:
		for group in ddictContigGroupHits[contig].iterkeys(): #For each group, add all the alignments to its respective organism
			dictOrgHits = {}
			for i in range(len(ddictContigGroupHits[contig][group])): #For each alignment, assign it to its respective organism
				alignList = ddictContigGroupHits[contig][group][i]
				taxonomyinfo = alignList[1].strip().split('|')
				taxonomy = taxonomyinfo[len(taxonomyinfo)-1]
				searchstring = args.organism + '__\w*'
				organism = re.search(searchstring, taxonomy).group()
				#print contig, group, organism
				dictOrgHits.setdefault(organism, []).append(alignList) #Create a dictionary of {organism: [alignments]}
			ddictGroupOrgHits.setdefault(group, {}).update(dictOrgHits) #Nest the above dictionary by groups {group: {org1: [alignments], org2:[alignments]}, group2...}


		#We will now create 2 nested dictionaries: 
		#1) ddictOrgGroupScore, where the organisms are keys, groups are keys, and scores are items of the 2nd nested dictionary
		#2) ddictGroupOrgScore, where the groups are keys, organisms are keys, and scores are items of the 2nd nested dictionary
		ddictOrgGroupScore = {}
		ddictGroupOrgScore = {}
		for group2 in ddictGroupOrgHits.iterkeys():
			dictGroupScore = {}
			dictOrgScore = {}
			for org in ddictGroupOrgHits[group2].iterkeys():
				orgInfo = []
				dictIndexScore = {}
			
             			#Calculate scores for each alignment for this organism within this group				
				for i in range(len(ddictGroupOrgHits[group2][org])):
					alignment = ddictGroupOrgHits[group2][org][i]
					start = int(alignment[6])
					end = int(alignment[7])
					alignLen = end + 1 - start
					groupLen = float(ddictContigGroupLen[contig][group2])
					percGroupCov = float(alignLen)/groupLen 
					percID = float(alignment[2])/100
					score = percGroupCov*percID
					#print contig, group2, org, score, alignLen			

					#Use vote method to get percID for best alignment of every base for this taxa level 
					for iRange in range(start, end + 1):
						if dictIndexScore.get(iRange, 0) != 0:
							oldScore = dictIndexScore[iRange][0]
							info = [score, percID]
							#print info, 'replace'
							if oldScore < score:
								dictIndexScore[iRange] = info
								#if iRange == end:
									#print "changed", contig, group2, org, score, percID, alignLen, groupLen, start, end, '\n', '\n'
						else:
							info = [score, percID]
							dictIndexScore[iRange] = info			
				
				sumPercID = 0 #Determine the vote method percent ID over all covered bases (this is newPercID)
				newStart, newEnd = sorted(dictIndexScore.keys())[0], sorted(dictIndexScore.keys())[len(dictIndexScore.keys())-1]
				#if int(newEnd) < int(newStart):
					#print contig, group2, org, newStart, newEnd
					#print sorted(dictIndexScore.keys())
				for i in range(len(dictIndexScore)):				
					#print dictIndexScore.keys()[0]
					sumPercID = sumPercID + dictIndexScore.values()[i][1]
				newPercID = sumPercID/len(dictIndexScore)
				#print len(dictIndexScore), ddictContigGroupLen[contig][group2]
				newCov = len(dictIndexScore)/float(ddictContigGroupLen[contig][group2]) #Determine the vote method coverage over the entire group
				newScore = newPercID*newCov #Calculate a new comprehensive score for this particular organism in the group
	
				#Create the two new dictionaries, retaining both the score information and # of nucleotides covered
				info2 = [newScore, len(dictIndexScore), newStart, newEnd]
				dictGroupScore[group2]=info2
				ddictOrgGroupScore.setdefault(org,{}).update(dictGroupScore)
				dictOrgScore[org] = info2
				ddictGroupOrgScore.setdefault(group2, {}).update(dictOrgScore)
   				
		dddictOrgGroupScore[contig] = ddictOrgGroupScore	
		dddictGroupOrgScore[contig] = ddictGroupOrgScore
	
filename2 = 'dddictOrgGroupScore_' + args.organism + '.json'
with open(filename2, "w") as outfile2:
	json.dump(dddictOrgGroupScore, outfile2)

filename3 = 'dddictGroupOrgScore_' + args.organism + '.json'
with open(filename3, "w") as outfile3:
	json.dump(dddictGroupOrgScore, outfile3)

file.close()
#print 'end'

'''
#This is for printing out information for R
for contig in dddictOrgGroupScore.keys():
	for org in dddictOrgGroupScore[contig].keys():
		for group in dddictOrgGroupScore[contig][org].keys():
			score = dddictOrgGroupScore[contig][org][group]
			print contig, org, group, score[0], score[1]
'''
'''
	#For this contig, we have now generated two dictionaries, which contain all genera, groups, and scores 
	#To determine whether HGT is present or not, we will classify groups within an organism into high, middle, and low scores
	dictOrgSets = {}
	#if len(ddictOrgGroupScore) == 1: #First, remove all contigs that are represented by only 1 organism
	#	continue

	#Determine which 'genes'/groups in each organism are high, middle, low/missing. Generate a dictionary: {org1: {high: set(Group1...), low: set(), middle:set()}, org2...}
	#dictOrgSets = {}	
    	delta, epsilon = args.delta, args.epsilon
	explainedbyone = False 
	for org2 in ddictOrgGroupScore.iterkeys():
		dictSet = {}
		setHighGroups = set()
		setMiddleGroups = set()
		setLowGroups = set()			
		for groups in ddictContigGroupHits[contig].iterkeys():
			if groups not in ddictOrgGroupScore[org2]:
				setLowGroups.add(groups) #Add all missing values to the 'low' group
			else:
				score = ddictOrgGroupScore[org2][groups][0]
				if score >= delta:
					#print contig, groups, org2, 'high'
					setHighGroups.add(groups) #Add all high confidence scores to the 'high' group
				elif score < delta and score > epsilon:
					#print contig, groups, org2, 'middle'
					setMiddleGroups.add(groups) #Add all middle confidence scores to the 'middle' group
				elif score <= epsilon:
					#`print contig, groups, org2, 'low'
					setLowGroups.add(groups) #Add all low confidence scores to the 'low' group
			
	#For each organism, create a dictionary with all its 'genes'
		if len(setHighGroups) == 0 and len(setMiddleGroups) == 0:
			#print contig, org2, 'Skip because low score'
			continue #Do not include organisms that consist of only low scores
		if len(setHighGroups) == len(ddictContigGroupHits[contig]):
			explainedbyone = True #Skip those that are completely explained by a genera with high annotations in all groups
		else:
			dictSet['high'] = setHighGroups
			dictSet['middle'] = setMiddleGroups
			dictSet['low'] = setLowGroups
			dictOrgSets[org2] = dictSet
			#print contig, org2, len(ddictContigGroupHits[contig]), len(setHighGroups), len(setMiddleGroups), len(setLowGroups)
	#print contig, len(dictOrgSets.keys()), len(ddictOrgGroupScore.keys()) #Can use this to determine number of organisms skipped, might output some info for this
	
	#Skip contigs that are explained by 0-1 organism, or are completely covered by an organism at the high level
	if len(dictOrgSets) <= 1: #These are contigs in which only 1 or 0 organisms are left after removing all the badly annotated ones #Only 37 of these
		continue #print contig, dictOrgSets
	if explainedbyone == True:
		continue

	#print contig #Leaves me with 98 contigs
	
	highLow = False #Remove all contigs that do not have at least 1 high --> low group
	for org3 in dictOrgSets:
		if len(dictOrgSets[org3]['high']) >= 1 and len(dictOrgSets[org3]['low']) >= 1 and highLow == False:
			#print contig, 'one passed'
			highLow = True
			#print contig, 'one passed'
		elif 
	if highLow == False:
		for org4 in dictOrgSets:
			print contig, len(dictOrgSets[org4]['high']), len(dictOrgSets[org4]['middle']), len(dictOrgSets[org4]['low'])

	
	#Organize the contigs by the organism with the highest number of groups in both the high and middle groups combined
	#For each contig (already within the loop)
	listOrgHighMid = []
	contigSet = set()
	for org3 in dictOrgSets:
		setHigh = dictOrgSets[org3]['high']
		setMid = dictOrgSets[org3]['middle']
		info3 = [org3, len(setHigh), len(setMid)]
		listOrgHighMid.append(info3)
	listOrgHighMid_sort = sorted(listOrgHighMid, key = operator.itemgetter(1,2), reverse = True) 
	
'''	
